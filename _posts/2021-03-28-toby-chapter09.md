---
layout: post
title: '9장 스프링 프로젝트 시작하기'
date: 2021-03-28 20:30:00
category: [toby-spring]
draft: false
comments: true
---

## 9.3 애플리케이션 아키텍처

### 9.3.1 계층형 아키텍처

-   아키텍처와 SoC
    -   지금까지...
        -   성격이 다른 코드가 얽혀 있는 것을 두 개의 오브젝트로 분리
        -   그 사이에 유연한 결합을 가질 수 있도록 인터페이스를 두기
        -   그 관계를 맺어주는 제3의 존재인 DI 컨테이너로 오브젝트끼리는 직접적으로 모르도록 만드는 것
    -   오브젝트보다 더 큰 단위 (아키텍처 레벨) / 오브젝트보다 더 작은 단위 (클래스 안의 메소드, 혹은 한 메소드 안의 코드들) 에도 적용 가능
    -   성격이 다른 것들은 아키텍처 레벨에서 분리해주는 것이 좋다
        -   계층형 아키텍처
        -   웹 기반 엔터프라이즈 애플리케이션 : 3계층 아키텍처
-   3계층 아키텍처와 수직 계층
    -   데이터 액세스 계층 (DAO)
        -   외부 시스템을 호출해서 서비스를 이용하는 것은 기반(infrastructure) 계층으로 따로 분류하기도 함
        -   DAO 코드 / JdbcTemplate / JDBC, 트랜잭션 동기화 / DataSource 순으로 추상화 레벨 높음 -> 낮음
    -   서비스 계층 (비즈니스 로직)
        -   잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성
        -   서비스 계층 (POJO 서비스 코드) <-> 기반 서비스 계층 (트랜잭션, 보안, 리모팅, 메일, 메시징, 스케쥴링..)
            -   일반적으로는 서비스 계층에서 기반 서비스 계층의 API를 호출해서 사용
                -   추상화된 인터페이스를 통해서만 접근하도록 만들어야 함
            -   반대로 서비스 계층의 코드를 기반 서비스 계층에서 실행시키는 경우도 있음 (ex. 스케쥴링)
    -   프레젠테이션 계층 (웹 기반 UI)
        -   최근에는 많은 프레젠테이션 로직이 클라이언트로 이동 중
            -   SOFEA (service oriented front end architecture)
-   계층형 아키텍처 설계의 원칙
    -   각 계층이 자신의 책임에 충실하게 작성
    -   계층 사이의 결합도는 낮게, 서로 침범하지 않게
    -   당연히! 계층 사이의 호출은 인터페이스를 통해 이뤄져야
        -   인터페이스에 아무 생각 없이 클래스의 모든 public 메소드를 호출하는 것은 인터페이스를 사용하는 가치를 떨어뜨리는 일
        -   다른 계층에서 꼭 필요한 메소드만 노출해야 함!

### 9.3.2 애플리케이션 정보 아키텍처

-   애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지 결정하기

-   DB/SQL 중심의 로직 구현 방식
    -   모든 계층의 코드가 예) '이름을 이용한 고객 조회' 라는 업무에 종속
        -   Java 코드는 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락
    -   변화에 매우 취약
-   거대한 서비스 계층 방식
    -   DAO가 돌려준 정보를 분석, 가공하며 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임
    -   거대한 서비스 계층 (fat service layer)

### 9.3.3 오브젝트 중심 아키텍처

-   도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보 전송하는 데 사용
-   데이터와 오브젝트
    -   DAO가 정보를 돌려줄 때도 Map<String, Object> 에 담아서 돌려주는 게 아니라 도메인 모델 오브젝트 형태로 돌려주게끔 한다
    -   테스트를 만들기도 훨씬 쉬움

```java
public class Category {
    int categoryId;
    String description;
    Set<Product> products;
}

public class Product {
    int productId;
    String name;
    int price;
    Category category;
}

```

-   도메인 오브젝트 사용의 문제점

    -   어떤 비즈니스 로직에서 필요한 정보가 몇 개의 필드뿐이라면 DAO에서 모든 필드를 채워서 전달하는 것은 낭비일 수도 있음
    -   그렇다고 비워서 전달해줬다가, 호출하는 쪽에서 그런 사실을 깜빡하고 액세스한다면?
        -   쨔잔 NPE
        -   결국 최적화를 고려해서 DAO를 작성하려면 비즈니스 로직에서 각 오브젝트를 어디까지 사용해야 하는지 알고 있어야 함
    -   해결?
        -   lazy loading?
        -   결국은 ORM 기술을 사용하는 게 좋지만...

-   빈약한 도메인 오브젝트 방식
    -   도메인 오브젝트에 정보만 담겨 있고 정보를 활용하는 아무런 기능도 없음
    -   도메인 오브젝트를 전혀 쓰지 않는 것보다는 나음
    -   비즈니스 로직은 서비스 계층에 위치하게 됨
-   풍성한 도메인 오브젝트 방식

    -   응집도가 높다
    -   해당 오브젝트나, 긴밀한 연관관계를 맺고 있는 관련 오브젝트의 정보와 기능만을 활용
    -   여러 종류의 도메인 오브젝트의 기능을 조합하는 복잡한 비즈니스 로직은 -> 서비스 계층으로 go
    -   스프링의 빈으로 관리되는 3계층의 오브젝트들은 도메인 오브젝트를 자유롭게 이용 가능하지만 그 반대는 안 됨

-   도메인 계층 방식
    -   어쨌든 이렇게 변경된 도메인 오브젝트들의 정보가 DB에 반영되려면 다른 계층에서 부가 작업이 필요함
    -   도메인 오브젝트가 스스로 필요한 정보는 DAO를 통해 가져오거나 (??) 생성이나 변경이 일어났을 때 직접 DAO에게 변경사항을 반영해달라고 요청 (!!) 하고 싶다
    -   도메인 오브젝트들이 하나의 독립적인 계층을 이뤄서 서비스 계층과 데이터 액세스 계층의 사이에 존재하게 하는 것
    -   스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP가 필요함.
    -   다만 주의하지 않으면 심각한 문제가 생길 수 있다 (이런 막강한 도메인 오브젝트를 프레젠테이션 계층에서 마구 사용한다면??)
        -   AspectJ의 정책/표준 강제화 (간단한 포인트컷 표현식으로 가능함) : AspectJ in Action 참조
        -   도메인 오브젝트는 도메인 계층을 벗어나지 못하게 하는 것 (DTO 활용)
            -   난 이게 좋아보이네...
    -   이런 제약과 불편을 감수하면서라도 이 방식을 택해야 하는 경우는?
        -   매우 복잡하고 변경이 잦은 도메인을 가졌을 경우
        -   그 정도로 복잡하지 않은 애플리케이션이라면 오히려 이런 방식이 과도한 부담을 줄 수도

### 9.3.4 스프링 애플리케이션을 위한 아키텍처 설계

-   계층형 아키텍처
    -   3계층을 단순화해 2계층으로 만든다면 : 서비스 계층, 데이터 액세스 계층
    -   서드파티 프레임워크, 라이브러리 적용
        -   '스프링이 지원하는 기술' 의 의미
            -   해당 기술을 스프링의 DI 패턴을 따라 사용할 수 있음
            -   스프링의 서비스 추상화가 적용됨
                -   JavaMail처럼 테스트가 매우 까다롭게 설계된 기술이고 DI해서 쓰기 불편할 경우 - 새로운 인터페이스를 추가할 필요가 있음
            -   스프링이 지지하는 프로그래밍 모델을 적용함
            -   템플릿/콜백을 지원
                -   네트워크 접근, 파일 IO처럼 실패할 가능성이 있는 시도를 하는 기술의 경우 적극 고려
                    -   또는 AOP, 예외 전환 적용 (특정 예외가 던져졌을 때에 대한 포인트컷을 만들어 추상화된 런타임 예외로 바꿔서 다시 던져줌)
                        > 스프링이 직접 지원 기능을 제공해주지 않으면 뭔가 시도해볼 생각 없이 스프링 이전 방식대로 코드를 만들어서 외부 기술을 사용하는 것은 부끄러운 일 (ㅠㅠ)
                        스프링을 사용하려면 스프링의 프로그래밍 모델과 그에 담긴 철학을 따르는 일관된 코드를 만드는 데 많은 관심을 기울여야
                          -  스프링이 아니어도 적용될 수 있는 말인 것 같다. 언어와 프레임워크에 담긴 철학....
